<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Realm of Legends: Premium Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            --ui-bg: #191521;
            --ui-border: #3f3452;
            --accent: #d4af37; /* Gold */
            --health: #e74c3c;
            --mana: #3498db;
            --xp: #9b59b6;
            --skill: #f39c12;
            --stamina: #f1c40f;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #050505;
            font-family: 'VT323', monospace;
            user-select: none;
            -webkit-user-select: none;
            color: white;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000;
            cursor: crosshair;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; /* Critical for retro look */
        }

        /* UI LAYER */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        /* HUD */
        .hud-panel {
            background: rgba(25, 21, 33, 0.85);
            border: 2px solid var(--ui-border);
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
            pointer-events: auto;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .stat-group { display: flex; flex-direction: column; width: 200px; }
        .bar-wrap {
            height: 16px; background: #111; border: 1px solid #555; margin: 2px 0;
            position: relative;
        }
        .bar-fill { height: 100%; transition: width 0.2s; }
        .hp-fill { background: var(--health); }
        .mana-fill { background: var(--mana); }
        .xp-fill { background: var(--xp); }
        .label { font-size: 18px; color: #ccc; text-shadow: 1px 1px 0 #000; }
        
        .currency { 
            font-size: 24px; color: var(--accent); 
            display: flex; align-items: center; gap: 5px;
        }

        .minimap-container {
            width: 150px; height: 150px;
            border: 3px solid var(--ui-border);
            background: #000;
            border-radius: 50%; /* Circular map */
            overflow: hidden;
            position: relative;
            opacity: 0.9;
        }
        #minimap { width: 100%; height: 100%; display: block; }

        /* MENUS */
        .modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; justify-content: center; align-items: center;
            z-index: 100;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            transition: opacity 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; display: none !important; }

        .window {
            width: 800px; max-width: 95%;
            background: var(--ui-bg);
            border: 4px double var(--ui-border);
            padding: 30px;
            position: relative;
            text-align: center;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        h1 { 
            font-size: 64px; color: var(--accent); margin: 0 0 20px 0; 
            text-shadow: 4px 4px 0 #000; letter-spacing: 2px;
        }
        h2 { color: #aaa; border-bottom: 1px solid #444; padding-bottom: 10px; }

        button {
            background: #2a2238;
            color: white;
            border: 2px solid var(--ui-border);
            font-family: 'VT323', monospace;
            font-size: 24px;
            padding: 10px 40px;
            cursor: pointer;
            transition: all 0.1s;
            margin: 10px;
            box-shadow: 0 4px 0 #15101d;
        }
        button:hover { background: #3d3152; transform: translateY(-2px); }
        button:active { transform: translateY(2px); box-shadow: 0 0 0; }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
            gap: 10px;
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
            background: #111;
            border: 2px inset #333;
        }

        .inv-slot {
            width: 64px; height: 64px;
            background: #222;
            border: 2px solid #444;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            cursor: pointer;
            position: relative;
        }
        .inv-slot:hover { border-color: var(--accent); background: #2a2a2a; }
        .inv-slot img { width: 32px; height: 32px; image-rendering: pixelated; }
        .inv-count { position: absolute; bottom: 2px; right: 4px; font-size: 16px; color: #fff; }

        /* NOTIFICATIONS */
        #toast-area {
            position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%);
            text-align: center; width: 100%; pointer-events: none;
        }
        .toast {
            background: linear-gradient(90deg, transparent, rgba(0,0,0,0.8), transparent);
            color: var(--accent);
            font-size: 24px;
            padding: 5px;
            margin-top: 5px;
            text-shadow: 1px 1px 0 #000;
            animation: floatUp 2s forwards;
        }
        @keyframes floatUp {
            0% { opacity: 0; transform: translateY(20px); }
            20% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }

        .controls-hint {
            font-size: 16px; color: #666; margin-top: 20px;
        }
        
        .key {
            display: inline-block;
            background: #333; border-bottom: 3px solid #111;
            padding: 2px 6px; border-radius: 4px; color: white;
        }
    </style>
    <style>
        .ability-slot {
            width: 50px; height: 50px; background: #222; border: 2px solid #444;
            border-radius: 5px; position: relative;
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAPFJREFUWEftltENgCAQBPf/d5sYQoJg002YgXj2x4JvX4CQT0iJgG+2G2gJgG/aD7QCwPftB1oC4Pv2A60A8H37gVYA+L79QCuA+C8E4AVQf0xAdwVUwBdg8gK0gL4A0gJ4AmgJgCegJQCegJYAeAJqCWAnoCYAnYCaAHQCasJ1AOtS4sYVYB2gugA8gO4AqgK4A6gK4A6gKgA8gOoA8ACqA8ADqA4AD6A6ADyA6gDwAKoDwANdC+DeA+sU4N4D6xTg3gPrFODeA+sU4N4D6xTg3gPrFPBfA/gA/gAUeHkY2wAAAABJRU5ErkJggg==');
            background-size: 32px 32px; background-position: center; background-repeat: no-repeat;
        }
        .cooldown-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            transform-origin: bottom;
            transform: scaleY(1);
            transition: transform 0.1s linear;
        }
        .ability-key {
            position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%);
            font-size: 16px; color: #ccc;
        }
    </style>
    <!-- Add a specific style for equipped items -->
    <style>
        .inv-slot.equipped {
            border-color: #4caf50; /* Green border for equipped */
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="main-canvas"></canvas>
    
    <!-- UI Layer -->
    <div id="ui-layer">
        <!-- Top Left HUD -->
        <div class="hud-panel" style="align-self: flex-start;">
            <div class="stat-group">
                <div class="label">HEALTH <span id="hp-val">100/100</span></div>
                <div class="bar-wrap"><div id="hp-bar" class="bar-fill hp-fill" style="width: 100%"></div></div>
                <div class="label">MANA <span id="mana-val">100/100</span></div>
                <div class="bar-wrap"><div id="mana-bar" class="bar-fill mana-fill" style="width: 100%"></div></div>
                <div class="label">XP LVL <span id="lvl-val" style="color: var(--accent)">1</span></div>
                <div class="bar-wrap"><div id="xp-bar" class="bar-fill xp-fill" style="width: 0%"></div></div>
            </div>
            <div class="currency">
                <span>ü™ô</span> <span id="gold-val">0</span>
            </div>
            <!-- Quest Tracker -->
            <div id="quest-tracker" class="hidden" style="margin-left: 20px; font-size: 18px;">
                <div id="quest-title" style="color: var(--accent);"></div>
                <div id="quest-progress"></div>
            </div>
        </div>

        <!-- Top Right Minimap -->
        <div class="minimap-container" style="position: absolute; top: 20px; right: 20px;">
            <canvas id="minimap"></canvas>
        </div>

        <!-- Center Notifications -->
        <div id="toast-area"></div>

        <!-- Bottom Hints -->
        <div style="text-align: center; opacity: 0.7; font-size: 18px; margin-bottom: 10px;">
            <span class="key">WASD</span> Move &nbsp; 
            <span class="key">SPACE</span> Attack &nbsp; 
            <span class="key">E</span> Interact &nbsp; 
            <span class="key">I</span> Inventory &nbsp; 
            <span class="key">ESC</span> Menu
            <span class="key">K</span> Skills
        </div>

        <!-- Ability Cooldowns -->
        <div id="ability-bar" style="position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px;">
            <div class="ability-slot">
                <div id="whirlwind-cooldown" class="cooldown-overlay"></div>
                <div class="ability-key">Q</div>
            </div>
            <div class="ability-slot" style="background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAARBJREFUWEftV8ENgCAQ3P/d6U4cQhA22U3YgXz2x4JvX4CQT0iJgG+2G2gJgG/aD7QCwPftB1oC4Pv2A60A8H37gVYA+L79QCuA+C8E4AVQf0xAdwVUwBdg8gK0gL4A0gJ4AmgJgCegJQCegJYAeAJqCWAnoCYAnYCaAHQCasJ1AOtS4sYVYB2gugA8gO4AqgK4A6gK4A6gKgA8gOoA8ACqA8ADqA4AD6A6ADyA6gDwAKoDwANdC+DeA+sU4N4D6xTg3gPrFODeA+sU4N4D6xTg3gPrFPBfA/gA/gAUeHkY2wAAAABJRU5ErkJggg==');">
                <div id="fireball-cooldown" class="cooldown-overlay"></div>
                <div class="ability-key">F</div>
            </div>
        </div>
    </div>

    <!-- Start/Menu Screen -->
    <div id="menu-screen" class="modal">
        <div class="window">
            <h1>REALM OF LEGENDS</h1>
            <p style="font-size: 24px; color: #888;">PREMIUM EDITION</p>
            <div style="margin: 40px 0;">
                <button onclick="Game.start()">ENTER WORLD</button>
                <br>
                <button onclick="Game.clearSave()" style="font-size: 18px; background: #382222; margin-top: 20px;">RESET DATA</button>
            </div>
            <div class="controls-hint">
                A living, breathing open world generated in your browser.
            </div>
        </div>
    </div>

    <!-- Inventory Screen -->
    <div id="inventory-screen" class="modal hidden">
        <div class="window">
            <h1>INVENTORY</h1>
            <div style="display:flex; justify-content: space-around; text-align: left;">
                <div>
                    <h2>Equipment</h2>
                    <div id="equip-grid" class="inventory-grid" style="grid-template-columns: repeat(2, 64px); max-height: 150px;"></div>
                    <h2 style="margin-top: 20px;">Stats</h2>
                    <p>‚öîÔ∏è Damage: <span id="stats-dmg">0</span></p>
                    <p>üõ°Ô∏è Armor: <span id="stats-def">0</span></p>
                    <p>‚ö° Speed: <span id="stats-spd">0</span></p>
                    <p>‚ù§Ô∏è Regen: <span id="stats-regen">0/s</span></p>
                </div>
                <div style="width: 400px;">
                    <h2>Bag</h2>
                    <div id="inv-grid" class="inventory-grid"></div>
                </div>
            </div>
            <button onclick="UI.toggleInventory()">CLOSE</button>
        </div>
    </div>

    <!-- Dialogue/Quest Screen -->
    <div id="dialogue-screen" class="modal hidden">
        <div class="window" style="width: 600px; text-align: left;">
            <h2 id="dialogue-title" style="margin-top: 0;">NPC Name</h2>
            <p id="dialogue-text" style="font-size: 22px; min-height: 100px;"></p>
            <div id="dialogue-options" style="text-align: center;">
                <!-- Options will be added here by JS -->
            </div>
        </div>
    </div>

    <!-- Shop Screen -->
    <div id="shop-screen" class="modal hidden">
        <div class="window">
            <h1>MERCHANT'S WARES</h1>
            <div id="shop-grid" class="inventory-grid" style="grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));">
                <!-- Shop items will be added here by JS -->
            </div>
            <button onclick="UI.closeShop()">LEAVE</button>
        </div>
    </div>

    <!-- Skill Tree Screen -->
    <div id="skill-tree-screen" class="modal hidden">
        <div class="window">
            <h1>SKILL TREE</h1>
            <p>Available Skill Points: <span id="skill-points-val" style="color: var(--skill);">0</span></p>
            <div id="skill-tree-container" style="display: flex; justify-content: space-around; text-align: left; margin-top: 20px;">
                <!-- Skill trees will be generated here by JS -->
            </div>
            <button onclick="UI.toggleSkillTree()">CLOSE</button>
        </div>
    </div>

    <!-- Skill Tree Screen -->
    <div id="skill-tree-screen" class="modal hidden">
        <div class="window">
            <h1>SKILL TREE</h1>
            <p>Available Skill Points: <span id="skill-points-val" style="color: var(--skill);">0</span></p>
            <div id="skill-tree-container" style="display: flex; justify-content: space-around; text-align: left; margin-top: 20px;">
                <!-- Skill trees will be generated here by JS -->
            </div>
            <button onclick="UI.toggleSkillTree()">CLOSE</button>
        </div>
    </div>
</div>

<script>
/**
 * REALM OF LEGENDS: PREMIUM EDITION
 * Single File Engine
 */

/* --- 1. ASSET GENERATOR (Procedural Pixel Art) --- */
const Assets = {
    cache: {},
    
    // Helper to create a canvas with pixel art
    createSprite(key, width, height, drawFn) {
        if (this.cache[key]) return this.cache[key];
        const c = document.createElement('canvas');
        c.width = width; c.height = height;
        const ctx = c.getContext('2d');
        drawFn(ctx, width, height);
        this.cache[key] = c;
        return c;
    },

    init() {
        // PLAYER
        this.createSprite('player_idle', 32, 32, (ctx) => {
            // Body
            ctx.fillStyle = '#333'; 
            ctx.fillRect(10, 14, 12, 10); 
            // Head
            ctx.fillStyle = '#fec'; 
            ctx.fillRect(10, 4, 12, 10);
            // Eyes
            ctx.fillStyle = '#000'; 
            ctx.fillRect(18, 7, 2, 2);
            // Helmet/Hair
            ctx.fillStyle = '#d4af37';
            ctx.fillRect(10, 2, 12, 4);
            ctx.fillRect(8, 4, 2, 8);
        });

        // ENEMY: ORC
        this.createSprite('orc', 32, 32, (ctx) => {
            ctx.fillStyle = '#4a7'; // Green skin
            ctx.fillRect(8, 6, 16, 20);
            ctx.fillStyle = '#253'; // Darker spots
            ctx.fillRect(10, 8, 4, 4);
            ctx.fillStyle = '#822'; // Warpaint
            ctx.fillRect(18, 10, 4, 2);
            ctx.fillStyle = '#111'; // Eyes
            ctx.fillRect(12, 10, 2, 2);
            ctx.fillRect(18, 10, 2, 2);
            ctx.fillStyle = '#543'; // Leather armor
            ctx.fillRect(8, 20, 16, 6);
        });

        // ENEMY: SLIME
        this.createSprite('slime', 32, 32, (ctx) => {
            ctx.fillStyle = 'rgba(50, 200, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(16, 22, 10, Math.PI, 0);
            ctx.fill();
            ctx.fillRect(6, 22, 20, 6);
            // Shine
            ctx.fillStyle = '#fff';
            ctx.fillRect(10, 18, 4, 4);
        });

        // TILE: GRASS
        this.createSprite('tile_grass', 32, 32, (ctx) => {
            ctx.fillStyle = '#2d5a27'; ctx.fillRect(0,0,32,32);
            ctx.fillStyle = '#3e7a36'; // Blades
            for(let i=0; i<10; i++) ctx.fillRect(Math.random()*30, Math.random()*30, 2, 2);
        });

        // TILE: WATER
        this.createSprite('tile_water', 32, 32, (ctx) => {
            ctx.fillStyle = '#275a75'; ctx.fillRect(0,0,32,32);
            ctx.fillStyle = '#3689aa'; // Foam
            for(let i=0; i<5; i++) ctx.fillRect(Math.random()*30, Math.random()*30, 4, 1);
        });
        
        // TILE: SAND
        this.createSprite('tile_sand', 32, 32, (ctx) => {
            ctx.fillStyle = '#d4c585'; ctx.fillRect(0,0,32,32);
            ctx.fillStyle = '#bfb070';
            for(let i=0; i<8; i++) ctx.fillRect(Math.random()*30, Math.random()*30, 1, 1);
        });

        // TILE: TREE (Object)
        this.createSprite('obj_tree', 64, 64, (ctx) => {
            // Trunk
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(26, 40, 12, 24);
            // Leaves
            ctx.fillStyle = '#1b5e20';
            ctx.beginPath();
            ctx.arc(32, 30, 25, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = '#2e7d32';
            ctx.beginPath();
            ctx.arc(32, 25, 18, 0, Math.PI*2);
            ctx.fill();
        });

        // ITEMS
        this.createSprite('item_potion', 32, 32, (ctx) => {
            ctx.fillStyle = '#fff'; ctx.fillRect(12, 8, 8, 20); // Bottle
            ctx.fillStyle = '#f00'; ctx.fillRect(14, 12, 4, 14); // Liquid
            ctx.fillStyle = '#852'; ctx.fillRect(12, 6, 8, 2); // Cork
        });

        this.createSprite('item_sword', 32, 32, (ctx) => {
            ctx.fillStyle = '#aaa'; ctx.fillRect(14, 4, 4, 24); // Blade
            ctx.fillStyle = '#852'; ctx.fillRect(12, 24, 8, 4); // Hilt
        });

        this.createSprite('item_battle_axe', 32, 32, (ctx) => {
            ctx.fillStyle = '#852'; ctx.fillRect(14, 4, 4, 24); // Handle
            ctx.fillStyle = '#aaa'; ctx.fillRect(10, 4, 12, 8); // Axe head
        });

        this.createSprite('item_bow', 32, 32, (ctx) => {
            ctx.strokeStyle = '#852'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(10, 16, 14, -Math.PI/2, Math.PI/2); ctx.stroke(); // Wood part
            ctx.fillStyle = '#ccc'; ctx.fillRect(10, 2, 2, 28); // String
        });
        this.createSprite('item_armor', 32, 32, (ctx) => {
            ctx.fillStyle = '#8d6e63'; ctx.fillRect(8, 6, 16, 20); // Body
            ctx.fillStyle = '#a1887f'; ctx.fillRect(10, 6, 12, 4); // Neckline
        });

        this.createSprite('item_steel_armor', 32, 32, (ctx) => {
            ctx.fillStyle = '#b0bec5'; ctx.fillRect(8, 6, 16, 20); // Body
            ctx.fillStyle = '#90a4ae'; ctx.fillRect(10, 6, 12, 4); // Neckline
        });

        this.createSprite('item_staff', 32, 32, (ctx) => {
            ctx.fillStyle = '#8d6e63'; ctx.fillRect(14, 2, 4, 28); // Staff
            ctx.fillStyle = '#3498db'; ctx.beginPath(); ctx.arc(16, 6, 5, 0, Math.PI*2); ctx.fill(); // Gem
        });

        // NPCS
        this.createSprite('npc_wizard', 32, 32, (ctx) => {
            // Robe
            ctx.fillStyle = '#3f51b5';
            ctx.fillRect(8, 12, 16, 20);
            // Face
            ctx.fillStyle = '#fec';
            ctx.fillRect(12, 8, 8, 8);
            // Beard
            ctx.fillStyle = '#fff';
            ctx.fillRect(10, 14, 12, 8);
            // Hat
            ctx.fillStyle = '#3f51b5';
            ctx.beginPath();
            ctx.moveTo(16, 0); ctx.lineTo(26, 12); ctx.lineTo(6, 12);
            ctx.fill();
        });

        this.createSprite('npc_merchant', 32, 32, (ctx) => {
            // Tunic
            ctx.fillStyle = '#e65100';
            ctx.fillRect(8, 14, 16, 18);
            // Apron
            ctx.fillStyle = '#d2b48c';
            ctx.fillRect(10, 16, 12, 14);
            // Face
            ctx.fillStyle = '#fec';
            ctx.fillRect(10, 6, 12, 10);
            // Hair
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(10, 4, 12, 4);
        });

        this.createSprite('npc_guard', 32, 32, (ctx) => {
            ctx.fillStyle = '#78909c'; ctx.fillRect(8, 12, 16, 18); // Armor
            ctx.fillStyle = '#fec'; ctx.fillRect(12, 6, 8, 8); // Face
            ctx.fillStyle = '#546e7a'; ctx.fillRect(10, 4, 12, 6); // Helmet
        });

        this.createSprite('npc_blacksmith', 32, 32, (ctx) => {
            ctx.fillStyle = '#6d4c41'; ctx.fillRect(8, 14, 16, 18); // Apron
            ctx.fillStyle = '#fec'; ctx.fillRect(10, 6, 12, 10); // Face
            ctx.fillStyle = '#455a64'; ctx.fillRect(10, 12, 12, 6); // Beard
            ctx.fillStyle = '#ff7043'; ctx.fillRect(10, 4, 12, 4); // Hair
        });

        this.createSprite('npc_old_man', 32, 32, (ctx) => {
            ctx.fillStyle = '#4e342e'; ctx.fillRect(8, 12, 16, 20); // Robe
            ctx.fillStyle = '#fec'; ctx.fillRect(12, 8, 8, 8); // Face
            ctx.fillStyle = '#e0e0e0'; ctx.fillRect(10, 14, 12, 8); // Beard
        });

        // BUILDINGS
        this.createSprite('building_house', 96, 96, (ctx) => {
            ctx.fillStyle = '#8d6e63'; ctx.fillRect(0, 32, 96, 64); // Walls
            ctx.fillStyle = '#b71c1c'; ctx.fillRect(-10, 0, 116, 40); // Roof
        });

        this.createSprite('building_library', 96, 96, (ctx) => {
            ctx.fillStyle = '#b0bec5'; ctx.fillRect(0, 32, 96, 64); // Walls
            ctx.fillStyle = '#3f51b5'; ctx.fillRect(-10, 0, 116, 40); // Roof
        });

        // ENEMY: SKELETON
        this.createSprite('skeleton', 32, 32, (ctx) => {
            ctx.fillStyle = '#e0e0e0'; // Bone color
            ctx.fillRect(14, 4, 4, 24); // Spine
            ctx.fillRect(10, 6, 12, 4); // Ribs
            ctx.fillRect(10, 12, 12, 4); // Ribs
            ctx.beginPath(); ctx.arc(16, 6, 5, 0, Math.PI*2); ctx.fill(); // Skull
            ctx.fillStyle = '#000'; ctx.fillRect(14, 5, 2, 2); ctx.fillRect(18, 5, 2, 2); // Eyes
        });

        // ENEMY: ORC KING
        this.createSprite('orc_king', 48, 48, (ctx) => {
            ctx.fillStyle = '#3a6'; // Darker Green skin
            ctx.fillRect(12, 9, 24, 30);
            ctx.fillStyle = '#d4af37'; // Gold crown
            ctx.fillRect(12, 6, 24, 6);
            ctx.fillRect(14, 2, 4, 4); ctx.fillRect(22, 2, 4, 4); ctx.fillRect(30, 2, 4, 4);
            ctx.fillStyle = '#111'; // Eyes
            ctx.fillRect(18, 15, 4, 4); ctx.fillRect(28, 15, 4, 4);
        });

        // ENEMY: SAND GOLEM
        this.createSprite('sand_golem', 32, 32, (ctx) => {
            ctx.fillStyle = '#bfb070'; // Sand color
            ctx.fillRect(6, 10, 20, 20); // Body
            ctx.fillRect(4, 4, 8, 8); ctx.fillRect(20, 4, 8, 8); // Shoulders
            ctx.fillStyle = '#d4af37'; ctx.fillRect(14, 14, 4, 4); // Core
        });

        // ENEMY: GHOST
        this.createSprite('ghost', 32, 32, (ctx) => {
            ctx.fillStyle = 'rgba(200, 220, 255, 0.7)';
            ctx.beginPath(); ctx.arc(16, 16, 12, 0, Math.PI*2); ctx.fill();
            ctx.fillRect(10, 20, 12, 10);
            ctx.fillStyle = '#000'; ctx.fillRect(12, 12, 3, 3); ctx.fillRect(18, 12, 3, 3);
        });

        // ENEMY: FOREST GUARDIAN
        this.createSprite('forest_guardian', 64, 64, (ctx) => {
            ctx.fillStyle = '#2e7d32'; // Dark green
            ctx.fillRect(20, 20, 24, 40); // Body
            ctx.fillStyle = '#1b5e20'; // Darker
            ctx.fillRect(16, 16, 32, 16); // Shoulders
            ctx.fillStyle = '#fff'; ctx.fillRect(26, 26, 4, 4); ctx.fillRect(34, 26, 4, 4); // Eyes
            ctx.fillStyle = '#8d6e63'; ctx.fillRect(28, 40, 8, 20); // Legs
        });

        // PROJECTILE: ARROW
        this.createSprite('projectile_arrow', 16, 16, (ctx) => {
            ctx.fillStyle = '#852'; ctx.fillRect(0, 7, 14, 2); // Shaft
            ctx.fillStyle = '#aaa'; ctx.fillRect(12, 6, 4, 4); // Head
        });

        // PROJECTILE: FIREBALL
        this.createSprite('projectile_fireball', 16, 16, (ctx) => {
            ctx.fillStyle = '#ff7043';
            ctx.beginPath(); ctx.arc(8, 8, 8, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#fdd835';
            ctx.beginPath(); ctx.arc(8, 8, 5, 0, Math.PI*2); ctx.fill();
        });
    }
};

/* --- 2. AUDIO ENGINE (Web Audio API) --- */
const AudioSys = {
    ctx: null,
    init() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    play(type) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);

        const now = this.ctx.currentTime;

        switch (type) {
            case 'hit': // Low thud
                osc.type = 'square';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.2);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
                break;
            case 'sword': // Swoosh noise (approximated with slide)
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.15);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
                break;
            case 'coin': // High ding
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1200, now);
                osc.frequency.setValueAtTime(1800, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.4);
                osc.start(now);
                osc.stop(now + 0.4);
                break;
            case 'levelup': 
                osc.type = 'square';
                osc.frequency.setValueAtTime(440, now);
                osc.frequency.setValueAtTime(554, now + 0.1);
                osc.frequency.setValueAtTime(659, now + 0.2);
                gain.gain.linearRampToValueAtTime(0, now + 0.6);
                osc.start(now);
                osc.stop(now + 0.6);
                break;
        }
    }
};

/* --- 3. WORLD GENERATION (Simplex-ish Noise) --- */
const World = {
    width: 400,
    height: 400,
    tileSize: 32,
    map: [],
    objects: [], // Trees, rocks
    
    // Simple noise function
    noise(x, y) {
        let val = Math.sin(x * 0.1) + Math.cos(y * 0.1) + Math.sin((x+y)*0.05);
        return val; // Range approx -2 to 2
    },

    generate() {
        this.map = new Array(this.width * this.height);
        this.objects = [];

        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                // Biome logic
                const n = this.noise(x, y) + Math.random() * 0.2;
                let type = 'grass';
                
                if (n < -1.2) type = 'deep_water';
                else if (n < -0.5) type = 'water';
                else if (n < -0.2) type = 'sand';
                else if (n > 1.2) type = 'mountain';
                else type = 'grass'; // Default

                this.map[y * this.width + x] = type;

                // Populate Objects
                if (type === 'grass' && Math.random() < 0.05) {
                    this.objects.push({x: x * this.tileSize, y: y * this.tileSize, type: 'tree'});
                }
            }
        }
    },

    getTile(x, y) {
        if (x < 0 || x >= this.width || y < 0 || y >= this.height) return 'water';
        return this.map[y * this.width + x];
    },

    isSolid(x, y) {
        const tx = Math.floor(x / this.tileSize);
        const ty = Math.floor(y / this.tileSize);
        const t = this.getTile(tx, ty);
        if (t === 'water' || t === 'deep_water' || t === 'mountain') return true;
        return false;
    },

    isWater(x, y) {
        const tx = Math.floor(x / this.tileSize);
        const ty = Math.floor(y / this.tileSize);
        const t = this.getTile(tx, ty);
        return (t === 'water' || t === 'deep_water');
    }
};

/* --- 4. ENTITIES & GAMEPLAY --- */
class Entity {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.w = 32; this.h = 32;
        this.vx = 0; this.vy = 0;
        this.dead = false;
        this.flash = 0;
    }
    update(dt) {
        this.x += this.vx;
        this.y += this.vy;
        if (this.flash > 0) this.flash--;
    }
    draw(ctx, camX, camY) {
        if (this.flash > 0 && Math.floor(Date.now()/50)%2===0) return; // Blink effect
        const sprite = Assets.cache[this.type] || Assets.cache['orc'];
        
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(this.x - camX + 16, this.y - camY + 28, 10, 4, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.drawImage(sprite, this.x - camX, this.y - camY);
    }
    getRect() {
        return {x: this.x+4, y: this.y+4, w: this.w-8, h: this.h-8};
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, 'player_idle');
        this.baseStats = { hp: 100, maxHp: 100, mana: 50, maxMana: 50, dmg: 5, def: 0, xp: 0, lvl: 1, gold: 0, attackSpeed: 1.0, hpRegen: 0, manaRegen: 0.5, skillPoints: 0 };
        this.stats = {...this.baseStats};
        this.inventory = [];
        this.equipment = { weapon: null, armor: null };
        this.skills = {}; // { skillId: level }
        this.cooldown = 0;
        this.speed = 180; // px per sec
        this.attackAnim = 0; // For weapon swing animation
        this.abilityCooldowns = { whirlwind: 0 };
        this.drownTimer = 0;
        this.activeQuest = null;
    }
    draw(ctx, camX, camY) {
        super.draw(ctx, camX, camY);
        this.drawEquipment(ctx, camX, camY);
    }
    update(dt) {
        this.vx = 0; this.vy = 0;
        if (Input.keys['w']) this.vy = -this.speed * dt;
        if (Input.keys['s']) this.vy = this.speed * dt;
        if (Input.keys['a']) this.vx = -this.speed * dt;
        if (Input.keys['d']) this.vx = this.speed * dt;

        // Collision
        if (World.isSolid(this.x + this.vx + 16, this.y + 16)) this.vx = 0;
        if (World.isSolid(this.x + 16, this.y + this.vy + 16)) this.vy = 0;

        this.recalculateStats();

        super.update(dt);

        // Attack
        if (Input.keys[' '] && this.cooldown <= 0) {
            const weaponType = this.equipment.weapon ? Items.get(this.equipment.weapon.id).type : 'sword';
            const baseSpeed = { 'axe': 0.8, 'bow': 0.6, 'staff': 0.5, 'sword': 0.4 }[weaponType];
            const attackSpeed = baseSpeed / this.stats.attackSpeed;
            this.attack();
            this.cooldown = attackSpeed; // seconds
            this.attackAnim = 0.3; // Start animation
        }
        if (Input.keys['q'] && this.abilityCooldowns.whirlwind <= 0) {
            this.useWhirlwind();
        }
        if (Input.keys['f'] && this.abilityCooldowns.fireball <= 0) {
            const weaponType = this.equipment.weapon ? Items.get(this.equipment.weapon.id).type : null;
            if (weaponType === 'staff' && this.stats.mana >= 10) {
                this.useFireball();
                this.baseStats.mana -= 10;
            }
        }
        if (this.attackAnim > 0) this.attackAnim -= dt;

        // Cooldowns
        if (this.abilityCooldowns.whirlwind > 0) this.abilityCooldowns.whirlwind -= dt;

        if (this.cooldown > 0) this.cooldown -= dt;

        // Health Regen
        if (this.stats.hp < this.stats.maxHp && this.stats.hp > 0) {
            this.baseStats.hp = Math.min(this.stats.maxHp, this.baseStats.hp + this.stats.hpRegen * dt);
        }

        // Mana Regen
        if (this.stats.mana < this.stats.maxMana) {
            this.baseStats.mana = Math.min(this.stats.maxMana, this.baseStats.mana + this.stats.manaRegen * dt);
        }

        // Drowning
        if (World.isWater(this.x + 16, this.y + 16)) {
            this.drownTimer += dt;
            if (this.drownTimer > 2) { // 2 seconds grace period
                this.takeDamage(5, true); // True for 'unblockable' damage
                Game.texts.push(new FloatingText(this.x, this.y, "Drowning!", "cyan"));
            }
        } else {
            this.drownTimer = 0;
        }
    }

    drawEquipment(ctx, camX, camY) {
        const weapon = this.equipment.weapon;
        if (!weapon) return; // Don't draw if nothing equipped

        const weaponType = weapon.id;
        const weaponSprite = Assets.cache['item_' + weaponType];
        ctx.save();
        ctx.translate(this.x - camX + 16, this.y - camY + 16);

        // Animation
        if (this.attackAnim > 0) {
            const swingProgress = (0.3 - this.attackAnim) / 0.3; // 0 to 1
            const angle = Math.sin(swingProgress * Math.PI) * -1.5; // Swing arc
            if (weaponType === 'battle_axe') {
                ctx.rotate(angle * 1.2); // Wider swing for axe
            } else {
                ctx.rotate(angle);
            }
        }

        // Draw weapon held out
        if (weaponType === 'battle_axe') {
            ctx.translate(10, -10); // Adjust position for axe
            ctx.drawImage(weaponSprite, -16, -16);
        } else if (weaponType === 'bow') {
            ctx.translate(10, 0); ctx.drawImage(weaponSprite, -16, -16);
        } else { // Sword
            ctx.translate(10, 0); // Adjust position for sword
            ctx.rotate(Math.PI / 4);
            ctx.drawImage(weaponSprite, -16, -16);
        }

        ctx.restore();
    }

    recalculateStats() {
        // Preserve current HP
        const currentHp = this.baseStats.hp;

        // Recalculate all stats from base
        this.stats.dmg = this.baseStats.dmg;
        this.stats.def = this.baseStats.def;
        this.stats.maxHp = this.baseStats.maxHp;
        this.stats.lvl = this.baseStats.lvl;
        this.stats.xp = this.baseStats.xp;
        this.stats.gold = this.baseStats.gold;
        this.stats.maxMana = this.baseStats.maxMana;
        this.stats.manaRegen = this.baseStats.manaRegen;
        this.stats.attackSpeed = this.baseStats.attackSpeed;

        if (this.equipment.weapon) this.stats.dmg += this.equipment.weapon.power;
        if (this.equipment.armor) this.stats.def += this.equipment.armor.power;

        // Apply skills

        // Restore current HP, capped at new maxHP
        this.baseStats.hp = Math.min(currentHp, this.stats.maxHp);
        this.stats.hp = this.baseStats.hp;
    }

    attack() {
        AudioSys.play('sword');
        Game.shake = 5;
        const center = { x: this.x + 16, y: this.y + 16 };
        const hitRange = 50;
        const weaponType = this.equipment.weapon ? Items.get(this.equipment.weapon.id).type : 'sword';

        if (weaponType === 'bow') {
            const angle = Math.atan2(Input.mouse.y - (this.y - Game.cam.y), Input.mouse.x - (this.x - Game.cam.x));
            Game.projectiles.push(new Projectile(center.x, center.y, angle, this.stats.dmg, 'arrow', this));
        } else {
            // Melee attack
            Game.entities.forEach(e => {
                if (e instanceof Enemy) {
                    const d = Math.hypot((e.x+16)-center.x, (e.y+16)-center.y);
                    if (d < hitRange) {
                        e.takeDamage(this.stats.dmg);
                    }
                }
            });
        }
    }

    useWhirlwind() {
        this.abilityCooldowns.whirlwind = 5; // 5 second cooldown
        AudioSys.play('sword');
        Game.shake = 8;

        // Big particle effect
        for(let i=0; i<360; i+=20) {
            const angle = i * Math.PI / 180;
            Game.particles.push(new Particle(this.x+16, this.y+16, '#fff', 2, {vx: Math.cos(angle)*150, vy: Math.sin(angle)*150}));
        }

        // Damage all nearby enemies
        Game.entities.forEach(e => {
            if (e instanceof Enemy && Math.hypot(e.x - this.x, e.y - this.y) < 100) {
                e.takeDamage(this.stats.dmg * 1.5); // Whirlwind does 150% damage
            }
        });
    }

    useFireball() {
        this.abilityCooldowns.fireball = 1.0; // 1 second cooldown
        const center = { x: this.x + 16, y: this.y + 16 };
        const angle = Math.atan2(Input.mouse.y - (this.y - Game.cam.y), Input.mouse.x - (this.x - Game.cam.x));
        Game.projectiles.push(new Projectile(center.x, center.y, angle, this.stats.dmg * 1.2, 'fireball', this));
    }

    takeDamage(amount, isUnblockable = false) {
        const reducedDmg = isUnblockable ? amount : Math.max(1, amount - this.stats.def);
        this.baseStats.hp -= reducedDmg;
        Game.texts.push(new FloatingText(this.x, this.y, `-${reducedDmg}`, "red"));
        Game.shake = 10;
        AudioSys.play('hit');
    }

    equip(item) {
        if (!item.slot) return;
        // Unequip old item
        if (this.equipment[item.slot]) {
            this.inventory.push(this.equipment[item.slot]);
        }
        // Equip new one
        this.equipment[item.slot] = item;
        this.inventory = this.inventory.filter(i => i !== item);
        this.recalculateStats();
        UI.toggleInventory(); // Refresh UI
        setTimeout(() => UI.toggleInventory(), 50);
    }

    gainXp(amount) {
        this.baseStats.xp += amount;
        const requiredXp = this.baseStats.lvl * 100;
        if (this.baseStats.xp >= requiredXp) {
            this.baseStats.xp -= requiredXp;
            this.baseStats.lvl++;
            this.baseStats.maxHp += 20;
            this.baseStats.hp = this.baseStats.maxHp;
            this.baseStats.dmg += 2;
            this.baseStats.attackSpeed += 0.05;
            this.baseStats.hpRegen += 0.2;
            this.baseStats.maxMana += 5;
            this.baseStats.skillPoints++;
            AudioSys.play('levelup');
            UI.notify("LEVEL UP! Stats Increased", "#gold");
            Game.particles.push(new Particle(this.x, this.y, '#fd0', 30));
        }
        this.recalculateStats();
    }

    acceptQuest(quest) {
        this.activeQuest = quest;
        this.activeQuest.progress = 0;
        UI.showQuest(quest);
        // Special spawns
        if (quest.id === 'forestGuardian') {
            const bossX = Game.player.x + (Math.random() - 0.5) * 400;
            const bossY = Game.player.y - 300;
            Game.entities.push(new Enemy(bossX, bossY, 'forest_guardian'));
            UI.notify("A Forest Guardian has appeared in the woods!", "red");
        }
    }
}

class Enemy extends Entity {
    constructor(x, y, type) {
        super(x, y, type);
        this.hp = { orc: 30, slime: 15, skeleton: 20, orc_king: 250, sand_golem: 80, ghost: 25, forest_guardian: 150 }[type];
        this.speed = { orc: 60, slime: 40, skeleton: 50, orc_king: 40, sand_golem: 30, ghost: 70, forest_guardian: 20 }[type];
    }
    takeDamage(amount) {
        this.hp -= amount;
        this.flash = 10;
        AudioSys.play('hit');
        Game.texts.push(new FloatingText(this.x, this.y, `-${amount}`, '#fff'));
        Game.particles.push(new Particle(this.x+16, this.y+16, '#a00', 5)); // Blood

        if (this.hp <= 0) {
            this.dead = true;
            const xpGain = { orc: 15, slime: 5, skeleton: 10, orc_king: 200, sand_golem: 50, ghost: 20, forest_guardian: 100 }[this.type];
            Game.player.gainXp(xpGain);

            // Gold drop
            if (this.type !== 'slime') { // Slimes are poor
                const goldDrop = this.type === 'orc_king' ? 100 + Math.floor(Math.random() * 50) : 5 + Math.floor(Math.random() * 5);
                Game.player.baseStats.gold += goldDrop;
                Game.texts.push(new FloatingText(this.x, this.y, `+${goldDrop} ü™ô`, "gold"));
                AudioSys.play('coin');
            }
            
            // Quest progress
            const q = Game.player.activeQuest;
            if (q && q.target === this.type && q.progress < q.needed) {
                q.progress++;
                UI.updateQuest();
            }

            // Loot drop
            const lootRoll = Math.random();
            if (this.type === 'orc_king' || lootRoll < 0.2) {
                Game.loot.push(new Loot(this.x, this.y, {id: 'potion', count: 1}));
            }
            if (this.type === 'orc_king' || lootRoll < 0.05) {
                Game.loot.push(new Loot(this.x, this.y, {id: 'sword', slot: 'weapon', power: 5}));
            }
            if (lootRoll < 0.02) { // Rare axe drop
                Game.loot.push(new Loot(this.x, this.y, {id: 'battle_axe', slot: 'weapon', power: 12}));
            }
            if (lootRoll < 0.03) { // Rare bow drop
                Game.loot.push(new Loot(this.x, this.y, {id: 'bow', slot: 'weapon', power: 7}));
            }
            if (lootRoll < 0.04) { // Rare armor drop
                Game.loot.push(new Loot(this.x, this.y, {id: 'steel_armor', slot: 'armor', power: 5}));
            }
        }
    }

    getRect() {
        // Make slime hitbox smaller
        if (this.type === 'slime') {
            return {x: this.x+8, y: this.y+16, w: this.w-16, h: this.h-16};
        }
        return super.getRect();
    }

    draw(ctx, camX, camY) {
        super.draw(ctx, camX, camY);
    }

    update(dt) {
        // AI: Chase Player
        const p = Game.player;
        const dist = Math.hypot(p.x - this.x, p.y - this.y);
        
        const chaseDist = this.type === 'skeleton' ? 300 : 200;
        const attackDist = this.type === 'skeleton' ? 250 : 35;

        if (dist < chaseDist && dist > attackDist) {
            const angle = Math.atan2(p.y - this.y, p.x - this.x);
            this.vx = Math.cos(angle) * this.speed * dt;
            this.vy = Math.sin(angle) * this.speed * dt;
        } else {
            this.vx = 0; this.vy = 0;
        }
        
        // Attack Logic
        if (dist < attackDist && Math.random() < 0.05) {
            if (this.type === 'skeleton') {
                // Ranged attack
                const angle = Math.atan2(p.y - this.y, p.x - this.x);
                Game.projectiles.push(new Projectile(this.x+16, this.y+16, angle, 8));
                AudioSys.play('sword'); // Arrow sound
            } else {
                // Melee attack
                const damage = { orc: 10, slime: 5, orc_king: 25, sand_golem: 15, ghost: 12, forest_guardian: 20 }[this.type];
                p.takeDamage(damage);
            }
        }

        super.update(dt);
    }
}

class NPC extends Entity {
    constructor(x, y, type, name) {
        super(x, y, type);
        this.name = name;
        this.interaction = null; // Function to call on interact
    }
    update(dt) {
        // NPCs don't move
    }
    draw(ctx, camX, camY) {
        super.draw(ctx, camX, camY);
    }
}

class Loot {
    constructor(x, y, item) {
        this.x = x; this.y = y; this.item = item;
        this.w = 32; this.h = 32;
        this.bounce = 0;
    }
    draw(ctx, camX, camY) {
        this.bounce += 0.1;
        const offY = Math.sin(this.bounce) * 5;
        ctx.drawImage(Assets.cache['item_potion'], this.x - camX, this.y - camY + offY);
        ctx.drawImage(Assets.cache['item_' + this.item.id], this.x - camX, this.y - camY + offY);
    }
}

class Projectile extends Entity {
    constructor(x, y, angle, damage, type, owner) {
        super(x, y, 'projectile_' + type);
        this.speed = 400;
        this.vx = Math.cos(angle) * this.speed;
        this.vy = Math.sin(angle) * this.speed;
        this.damage = damage;
        this.life = 3; // seconds
        this.owner = owner;
    }
    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= dt;
        if (this.life <= 0) this.dead = true;
        if (World.isSolid(this.x, this.y)) this.dead = true;

        // Check collision with player
        if (this.owner instanceof Enemy) {
            const p = Game.player;
            if (Math.hypot(p.x+16 - this.x, p.y+16 - this.y) < 20) {
                p.takeDamage(this.damage);
                this.dead = true;
            }
        }
    }
    draw(ctx, camX, camY) {
        // Don't draw shadow
        const sprite = Assets.cache[this.type];
        ctx.save();
        ctx.translate(this.x - camX, this.y - camY);
        ctx.rotate(Math.atan2(this.vy, this.vx));
        ctx.drawImage(sprite, -8, -8);
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color, count, vel={vx: (Math.random()-0.5)*100, vy: (Math.random()-0.5)*100}) {
        this.parts = [];
        for(let i=0; i<count; i++) {
            this.parts.push({
                x: x, y: y, 
                vx: vel.vx * (0.8 + Math.random()*0.4), 
                vy: vel.vy * (0.8 + Math.random()*0.4),
                life: 1.0,
                color: color
            });
        }
    }
    update(dt) {
        this.parts.forEach(p => {
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.life -= dt * 2;
        });
        this.parts = this.parts.filter(p => p.life > 0);
    }
    draw(ctx, camX, camY) {
        this.parts.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - camX, p.y - camY, 3, 3);
        });
        ctx.globalAlpha = 1;
    }
    isDead() { return this.parts.length === 0; }
}

class FloatingText {
    constructor(x, y, text, color) {
        this.x = x; this.y = y; this.text = text; this.color = color;
        this.life = 1.0; this.vy = -30;
    }
    update(dt) {
        this.y += this.vy * dt;
        this.life -= dt;
    }
    draw(ctx, camX, camY) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.font = "20px 'VT323'";
        ctx.fillText(this.text, this.x - camX + 16, this.y - camY);
        ctx.globalAlpha = 1;
    }
}

/* --- 5. CORE ENGINE --- */
const Input = {
    keys: {},
    init() {
        window.addEventListener('keydown', e => {
            this.keys[e.key] = true;
            if (e.key === 'Escape') Game.togglePause();
            if (e.key === 'i' || e.key === 'I') UI.toggleInventory(); // Q is now an ability
            if (e.key === 'e' || e.key === 'E') Game.interact();
            if (e.key === 'k' || e.key === 'K') UI.toggleSkillTree();
        });
        window.addEventListener('keyup', e => this.keys[e.key] = false);
    }
};

const Skills = {
    warrior: {
        strength: { name: 'Strength', desc: '+5 Damage per level', max: 5 },
        vitality: { name: 'Vitality', desc: '+10 Max HP per level', max: 5 },
        berserk: { name: 'Berserk', desc: '+10% Attack Speed per level', max: 3 }
    },
    ranger: {
        precision: { name: 'Precision', desc: '+10% Damage with bows per level', max: 5 },
        swiftness: { name: 'Swiftness', desc: '+20 Speed per level', max: 5 },
        eagle_eye: { name: 'Eagle Eye', desc: '+50% Range per level', max: 3 }
    },
    mage: {
        intellect: { name: 'Intellect', desc: '+5 Max Mana per level', max: 5 },
        focus: { name: 'Focus', desc: '+20% Mana Regen per level', max: 5 },
        arcane_power: { name: 'Arcane Power', desc: '+15% Magic Damage per level', max: 3 }
    }
};

const Quests = {
    slimeMenace: {
        id: 'slimeMenace',
        title: "The Slime Menace",
        npc: 'Wizard',
        description: "The nearby plains are overrun with slimes! Please, adventurer, could you defeat 10 of them to make the area safer?",
        target: 'slime', // The enemy type to kill
        needed: 10,
        reward: { 
            xp: 150, 
            gold: 75,
            item: { id: 'sword', slot: 'weapon', power: 8, name: "Wizard's Blade" } // Special reward
        },
        completionText: "Amazing! You've thinned their numbers. Please, take this for your troubles."
    },
    orcMaterials: {
        id: 'orcMaterials',
        title: "A Merchant's Plea",
        npc: 'Merchant',
        description: "Those pesky orcs keep stealing my supplies! If you could recover 5... 'orc tusks' for me, I'll make it worth your while.",
        target: 'orc', needed: 5,
        reward: { xp: 100, gold: 150 },
        completionText: "Ah, splendid! These will teach them a lesson. Here is your payment."
    },
    golemProblem: {
        id: 'golemProblem',
        title: "The Golem Problem",
        npc: 'Guard Captain',
        description: "The desert paths are blocked by enchanted Sand Golems. It's too dangerous for the caravans. Can you destroy 3 of them?",
        target: 'sand_golem', needed: 3,
        reward: { xp: 250, gold: 200 },
        completionText: "Excellent work, soldier. The trade routes are safer thanks to you."
    },
    ancientKnowledge: {
        id: 'ancientKnowledge',
        title: "Ancient Knowledge",
        npc: 'Old Man',
        description: "The Orc King... I've heard he carries an ancient tablet. If you ever defeat him, would you bring it to me? I must study it.",
        target: 'orc_king', needed: 1,
        reward: { xp: 500, gold: 100 },
        completionText: "Incredible! The legends were true. Thank you, hero. This knowledge is priceless."
    },
    craftSword: {
        id: 'craftSword',
        title: "Forging a Legend",
        npc: 'Blacksmith',
        description: "I need materials to craft a powerful sword. Bring me 5 iron ore and 2 leather strips.",
        type: 'GATHER',
        requirements: { iron_ore: 5, leather_strip: 2 },
        reward: { xp: 200, gold: 150, item: { id: 'legendary_sword', slot: 'weapon', power: 15, name: 'Legendary Sword' } },
        completionText: "Excellent! Here's your sword, forged with the finest materials."
    },
    investigateRuins: {
        id: 'investigateRuins',
        title: "Mysterious Ruins",
        npc: 'Librarian',
        description: "Strange lights have been seen near the ancient ruins. Go investigate and report back what you find.",
        type: 'TALK_TO',
        target: 'Shady Figure',
        reward: { xp: 100, gold: 50 },
        completionText: "Thank you for your bravery. The ruins hold secrets we must protect."
    },
    forestGuardian: {
        id: 'forestGuardian',
        title: "The Forest Guardian",
        npc: 'Guard Captain',
        description: "A fearsome Forest Guardian protects the deep woods. Defeat it to ensure safe passage.",
        target: 'forest_guardian', needed: 1,
        reward: { xp: 400, gold: 300 },
        completionText: "You've done it! The woods are safer now."
    }
};

const Items = {
    sword: { type: 'sword', slot: 'weapon', power: 5, name: 'Iron Sword' },
    battle_axe: { type: 'axe', slot: 'weapon', power: 12, name: 'Battle Axe' },
    bow: { type: 'bow', slot: 'weapon', power: 7, name: 'Wooden Bow' },
    staff: { type: 'staff', slot: 'weapon', power: 3, name: 'Apprentice Staff' },
    fire_staff: { type: 'staff', slot: 'weapon', power: 6, name: 'Fire Staff' },
    armor: { type: 'armor', slot: 'armor', power: 2, name: 'Leather Armor' },
    steel_armor: { type: 'armor', slot: 'armor', power: 5, name: 'Steel Armor' },
    legendary_sword: { type: 'sword', slot: 'weapon', power: 15, name: 'Legendary Sword' },
    iron_ore: { type: 'material', name: 'Iron Ore' },
    leather_strip: { type: 'material', name: 'Leather Strip' },
    potion: { type: 'consumable', name: 'Health Potion' },
    get(id) { return this[id]; }
};


const Game = {
    canvas: null, ctx: null,
    player: null,
    entities: [], loot: [], particles: [], texts: [], projectiles: [],
    lastTime: 0,
    shake: 0,
    state: 'MENU', // MENU, PLAY, PAUSE
    cam: {x:0, y:0},
    spawnPoint: {x:0, y:0},
    dayTime: 0, // 0 to 1

    init() {
        this.canvas = document.getElementById('main-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        Assets.init();
        Input.init();
        
        // Initial Render for Menu bg
        this.ctx.fillStyle = '#111';
        this.ctx.fillRect(0,0,this.canvas.width, this.canvas.height);
    },

    start() {
        AudioSys.init();
        document.getElementById('menu-screen').classList.add('hidden');
        
        // Try Load
        const save = localStorage.getItem('rol_save');
        if (save) {
            this.loadGame(JSON.parse(save));
        } else {
            this.newGame();
        }

        this.state = 'PLAY';
        this.lastTime = performance.now() / 1000;
        requestAnimationFrame(l => this.loop(l));
        
        // Auto Save Loop
        setInterval(() => this.saveGame(), 10000);
    },

    newGame() {
        World.generate();
        
        // FIX: Find a safe spawn point (Grass/Sand) instead of hardcoded center
        let spawnX = 0;
        let spawnY = 0;
        let foundSpot = false;
        
        const cx = Math.floor(World.width / 2);
        const cy = Math.floor(World.height / 2);
        
        // Spiral search for land
        for (let r = 0; r < 100; r++) {
            // Search range [-r to +r]
            for (let y = cy - r; y <= cy + r; y++) {
                for (let x = cx - r; x <= cx + r; x++) {
                    // Check bounds
                    if (x >= 0 && x < World.width && y >= 0 && y < World.height) {
                        // Check if solid (water/mountain are solid)
                        // We pass pixel coords to isSolid, but here we have grid coords, so multiply by tileSize
                        if (!World.isSolid(x * World.tileSize, y * World.tileSize)) {
                            spawnX = x * World.tileSize;
                            spawnY = y * World.tileSize;
                            foundSpot = true;
                            break;
                        }
                    }
                }
                if (foundSpot) break;
            }
            if (foundSpot) break;
        }

        this.spawnPoint = {x: spawnX, y: spawnY};

        this.player = new Player(spawnX, spawnY);
        this.player.inventory.push({id: 'potion', count: 3});
        
        // Spawn Mobs around the player's actual spawn point
        const startingEnemyTypes = ['slime'];
        const outerEnemyTypes = ['orc', 'slime', 'skeleton', 'sand_golem'];
        this.entities = [];
        for(let i=0; i<200; i++) { // More enemies for bigger map
            const ex = spawnX + (Math.random()-0.5)*4000;
            const ey = spawnY + (Math.random()-0.5)*4000;
            if(!World.isSolid(ex, ey) && Math.hypot(ex - spawnX, ey - spawnY) > 600) { // No enemies in starting town
                const distFromSpawn = Math.hypot(ex - spawnX, ey - spawnY);
                const type = distFromSpawn < 800 ? startingEnemyTypes[Math.floor(Math.random() * startingEnemyTypes.length)] : outerEnemyTypes[Math.floor(Math.random() * outerEnemyTypes.length)];
                this.entities.push(new Enemy(ex, ey, type));
            }
        }

        // Helper to find a safe spot for NPCs
        const findSafeSpot = (x, y) => {
            for(let r=0; r<5; r++) { // Search in a 5-tile radius
                const checkX = x + (Math.random()-0.5) * r * World.tileSize;
                const checkY = y + (Math.random()-0.5) * r * World.tileSize;
                if (!World.isSolid(checkX, checkY)) return {x: checkX, y: checkY};
            }
            return {x, y}; // Fallback
        }

        // Spawn NPCs in the city
        const wizPos = findSafeSpot(spawnX + 64, spawnY);
        const wizard = new NPC(wizPos.x, wizPos.y, 'npc_wizard', 'Wizard');
        wizard.interaction = () => UI.showDialogue(wizard);
        this.entities.push(wizard);

        const merchPos = findSafeSpot(spawnX - 64, spawnY);
        const merchant = new NPC(merchPos.x, merchPos.y, 'npc_merchant', 'Merchant');
        merchant.interaction = () => UI.showShop(merchant);
        this.entities.push(merchant);

        const guardPos = findSafeSpot(spawnX, spawnY - 80);
        const guard = new NPC(guardPos.x, guardPos.y, 'npc_guard', 'Guard Captain');
        guard.interaction = () => UI.showDialogue(guard);
        this.entities.push(guard);

        const oldManPos = findSafeSpot(spawnX + 128, spawnY + 50);
        const oldMan = new NPC(oldManPos.x, oldManPos.y, 'npc_old_man', 'Old Man');
        oldMan.interaction = () => UI.showDialogue(oldMan);
        this.entities.push(oldMan);

        const librarianPos = findSafeSpot(spawnX + 140, spawnY + 60);
        const librarian = new NPC(librarianPos.x, librarianPos.y, 'npc_wizard', 'Librarian'); // Reuse wizard sprite
        librarian.interaction = () => UI.showDialogue(librarian);
        this.entities.push(librarian);

        const shadyPos = findSafeSpot(spawnX + 200, spawnY + 100);
        const shadyFigure = new NPC(shadyPos.x, shadyPos.y, 'npc_merchant', 'Shady Figure'); // Reuse merchant
        shadyFigure.interaction = () => UI.showDialogue(shadyFigure);
        this.entities.push(shadyFigure);

        this.entities.push(merchant);

        // Add a blacksmith
        const blacksmithPos = findSafeSpot(spawnX - 100, spawnY - 50);
        const blacksmith = new NPC(blacksmithPos.x, blacksmithPos.y, 'npc_blacksmith', 'Blacksmith');
        blacksmith.interaction = () => UI.showDialogue(blacksmith);
        this.entities.push(blacksmith);
        
        UI.notify("World Generated!", "#4f4");
    },

    interact() {
        // Check for NPCs first
        let interacted = false;
        this.entities.forEach(e => {
            if (e instanceof NPC) {
                const d = Math.hypot(this.player.x - e.x, this.player.y - e.y);
                if (d < 50 && e.interaction) {
                    e.interaction();
                    interacted = true;
                }
            }
        });
        if (interacted) return;

        // Check for loot
        let picked = false;
        this.loot = this.loot.filter(l => {
            const d = Math.hypot(this.player.x - l.x, this.player.y - l.y);
            if (d < 40) {
                this.player.inventory.push(l.item);
                this.texts.push(new FloatingText(this.player.x, this.player.y, `+${l.item.id}`, "gold"));
                picked = true;
                return false;
            }
            return true;
        });
        if (!picked) {
            // Maybe use potion?
            const potIndex = this.player.inventory.findIndex(i => i.id === 'potion');
            if (potIndex > -1 && this.player.baseStats.hp < this.player.stats.maxHp) {
                this.player.baseStats.hp = Math.min(this.player.stats.maxHp, this.player.baseStats.hp + 50);
                
                // Handle stacked vs unstacked potions
                const pot = this.player.inventory[potIndex];
                pot.count--;
                if (pot.count <= 0) {
                    this.player.inventory.splice(potIndex, 1);
                }

                AudioSys.play('levelup'); // heal sound
                this.texts.push(new FloatingText(this.player.x, this.player.y, "+50 HP", "green"));
            }
        }
    },

    loop(now) {
        requestAnimationFrame(l => this.loop(l));
        const t = now / 1000;
        const dt = Math.min(t - this.lastTime, 0.1);
        this.lastTime = t;

        if (this.state !== 'PLAY') return;

        this.update(dt);
        this.draw();
        UI.update();
    },

    update(dt) {
        // Day Cycle
        this.dayTime += dt * 0.01; // Slow cycle
        
        // Shake decay
        if(this.shake > 0) this.shake -= dt * 20;
        if(this.shake < 0) this.shake = 0;

        this.player.update(dt);
        
        // Camera Follow
        this.cam.x = this.player.x - this.canvas.width / 2;
        this.cam.y = this.player.y - this.canvas.height / 2;

        // Entities
        this.entities.forEach(e => e.update(dt));
        this.entities = this.entities.filter(e => !e.dead);

        // Projectiles
        this.projectiles.forEach(p => p.update(dt));
        this.projectiles = this.projectiles.filter(p => !p.dead);

        // Particles & Text
        this.particles.forEach(p => p.update(dt));
        this.particles = this.particles.filter(p => !p.isDead());
        this.texts.forEach(t => t.update(dt));
        this.texts = this.texts.filter(t => t.life > 0);

        // Respawn logic
        if (this.entities.length < 20) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 500;
            const ex = this.player.x + Math.cos(angle) * dist;
            const ey = this.player.y + Math.sin(angle) * dist;
            if (!World.isSolid(ex, ey)) {
                const light = (Math.sin(this.dayTime) + 1) / 2;
                let type;
                if (light < 0.2) { // Night
                    type = Math.random() > 0.5 ? 'ghost' : (Math.random() > 0.5 ? 'skeleton' : 'orc');
                } else {
                    type = Math.random() > 0.3 ? 'orc' : (Math.random() > 0.5 ? 'slime' : 'skeleton');
                }
                this.entities.push(new Enemy(ex, ey, type));
            }
        }
        
        // Check Game Over
        if (this.player.baseStats.hp <= 0) {
            UI.notify("You have fallen...", "red");
            this.player.baseStats.hp = this.player.stats.maxHp / 2; // Respawn with 50% health
            this.player.baseStats.gold = Math.floor(this.player.baseStats.gold * 0.8); // Lose 20% gold
            UI.notify("You lost some gold.", "orange");
            // Teleport to spawn
            this.player.x = Game.spawnPoint.x;
            this.player.y = Game.spawnPoint.y;
        }
    },

    draw() {
        // Background Clear
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Shake
        const sx = (Math.random() - 0.5) * this.shake;
        const sy = (Math.random() - 0.5) * this.shake;

        this.ctx.save();
        this.ctx.translate(-this.cam.x + sx, -this.cam.y + sy);

        // Draw Player House
        const houseSprite = Assets.cache['building_house'];
        this.ctx.drawImage(houseSprite, this.spawnPoint.x - houseSprite.width/2, this.spawnPoint.y - houseSprite.height/2);

        // Draw Library
        const librarySprite = Assets.cache['building_library'];
        this.ctx.drawImage(librarySprite, this.spawnPoint.x + 128 - librarySprite.width/2, this.spawnPoint.y + 50 - librarySprite.height/2);

        // Draw Forge
        const forgeSprite = Assets.cache['building_house']; // Reuse house sprite for forge
        this.ctx.drawImage(forgeSprite, this.spawnPoint.x - 150 - forgeSprite.width/2, this.spawnPoint.y - 50 - forgeSprite.height/2);

        // 1. Draw Tiles (Optimized Culling)
        const startCol = Math.floor(this.cam.x / World.tileSize);
        const endCol = startCol + (this.canvas.width / World.tileSize) + 1;
        const startRow = Math.floor(this.cam.y / World.tileSize);
        const endRow = startRow + (this.canvas.height / World.tileSize) + 1;

        for (let y = startRow; y <= endRow; y++) {
            for (let x = startCol; x <= endCol; x++) {
                const tile = World.getTile(x, y);
                let sprite = Assets.cache['tile_water'];
                if (tile === 'grass') sprite = Assets.cache['tile_grass'];
                if (tile === 'sand') sprite = Assets.cache['tile_sand'];
                
                // Draw Tile
                this.ctx.drawImage(sprite, x * World.tileSize, y * World.tileSize);
                
                // Draw Water Reflection
                if (tile === 'water') {
                    this.ctx.fillStyle = `rgba(255,255,255,${Math.sin(this.dayTime*5 + x)*0.1})`;
                    this.ctx.fillRect(x * World.tileSize, y * World.tileSize, 32, 32);
                }
            }
        }

        // 2. Draw Trees & Objects (Sorted by Y for pseudo-3D)
        // We just draw trees that are in view
        World.objects.forEach(o => {
            if (o.x > this.cam.x - 100 && o.x < this.cam.x + this.canvas.width + 100 &&
                o.y > this.cam.y - 100 && o.y < this.cam.y + this.canvas.height + 100) {
                this.ctx.drawImage(Assets.cache['obj_tree'], o.x - 16, o.y - 32);
            }
        });

        // 3. Loot
        this.loot.forEach(l => l.draw(this.ctx, 0, 0));

        // 4. Entities (Sort Player and Enemies by Y)
        const renderList = [...this.entities, this.player, ...this.projectiles];
        renderList.sort((a, b) => a.y - b.y);
        renderList.forEach(e => e.draw(this.ctx, 0, 0));

        // 5. Particles
        this.particles.forEach(p => p.draw(this.ctx, 0, 0));
        this.texts.forEach(t => t.draw(this.ctx, 0, 0));

        // Draw Whirlwind cooldown on player
        if (this.player.abilityCooldowns.whirlwind > 0) {
            const p = this.player;
            const radius = 100;
            const progress = (5 - p.abilityCooldowns.whirlwind) / 5;
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(p.x + 16, p.y + 16, radius, -Math.PI/2, -Math.PI/2 + progress * Math.PI * 2);
            this.ctx.stroke();
        }


        this.ctx.restore();

        // 6. Lighting Overlay (Day/Night)
        const light = (Math.sin(this.dayTime) + 1) / 2; // 0 to 1
        const darkness = 0.6 - (light * 0.6); // Max darkness 0.6
        this.ctx.fillStyle = `rgba(0, 0, 20, ${darkness})`;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // 7. Minimap Draw
        UI.drawMinimap();
    },

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.ctx.imageSmoothingEnabled = false;
    },

    togglePause() {
        if(this.state === 'PLAY') {
            this.state = 'PAUSE';
            UI.notify("PAUSED");
        } else if (this.state === 'PAUSE') {
            this.state = 'PLAY';
        }
    },

    saveGame() {
        const data = {
            player: this.player.baseStats,
            inv: this.player.inventory,
            pos: {x: this.player.x, y: this.player.y}
        };
        localStorage.setItem('rol_save', JSON.stringify(data));
        UI.notify("Game Saved", "#aaa");
    },

    loadGame(data) {
        this.newGame(); // Init world first to generate map
        
        this.player.baseStats = data.player;
        this.player.inventory = data.inv;
        
        // Safety check: If loaded position is in water (due to bug), move to safe spot
        if (World.isSolid(data.pos.x, data.pos.y)) {
             UI.notify("Stuck in water? Moving to safety...", "orange");
             // Use the spawn point found by newGame() which is safe
        } else {
             this.player.x = data.pos.x;
             this.player.y = data.pos.y;
        }
        
        this.player.recalculateStats();
        UI.notify("Welcome Back!", "#gold");
    },

    clearSave() {
        localStorage.removeItem('rol_save');
        location.reload();
    }
};

/* --- 6. UI MANAGER --- */
const UI = {
    minimapCanvas: null,
    mCtx: null,

    update() {
        // HUD
        const p = Game.player;
        document.getElementById('hp-val').innerText = `${Math.ceil(p.baseStats.hp)}/${p.stats.maxHp}`;
        document.getElementById('hp-bar').style.width = `${(p.stats.hp/p.stats.maxHp)*100}%`;
        document.getElementById('mana-val').innerText = `${Math.ceil(p.baseStats.mana)}/${p.stats.maxMana}`;
        document.getElementById('mana-bar').style.width = `${(p.stats.mana/p.stats.maxMana)*100}%`;
        document.getElementById('xp-bar').style.width = `${(p.baseStats.xp/(p.baseStats.lvl*100))*100}%`;
        document.getElementById('lvl-val').innerText = p.baseStats.lvl;
        document.getElementById('gold-val').innerText = p.stats.gold;
        document.getElementById('skill-points-val').innerText = p.baseStats.skillPoints;

        // Ability Cooldowns
        const wwCooldown = p.abilityCooldowns.whirlwind || 0;
        const wwMaxCooldown = 5;
        const wwOverlay = document.getElementById('whirlwind-cooldown');
        if (wwOverlay) {
            const scaleY = Math.max(0, wwCooldown / wwMaxCooldown);
            wwOverlay.style.transform = `scaleY(${scaleY})`;
        }
    },

    notify(msg, color='#fff') {
        const area = document.getElementById('toast-area');
        const el = document.createElement('div');
        el.className = 'toast';
        el.style.color = color;
        el.innerText = msg;
        area.appendChild(el);
        setTimeout(() => el.remove(), 2000);
    },

    toggleInventory() {
        const el = document.getElementById('inventory-screen');
        el.classList.toggle('hidden');
        if (!el.classList.contains('hidden')) {
            // Update inv UI
            Game.player.recalculateStats();
            document.getElementById('stats-dmg').innerText = Game.player.stats.dmg;
            document.getElementById('stats-def').innerText = Game.player.stats.def;
            document.getElementById('stats-spd').innerText = Game.player.speed;
            document.getElementById('stats-regen').innerText = Game.player.stats.hpRegen.toFixed(1) + '/s';
            document.getElementById('stats-regen').innerText = Game.player.stats.hpRegen.toFixed(1) + '/s';
            
            const grid = document.getElementById('inv-grid');
            grid.innerHTML = '';
            // Group stacked items
            const groupedInv = Game.player.inventory.reduce((acc, item) => {
                if (item.id === 'potion') {
                    if (!acc['potion']) acc['potion'] = { ...item, count: 0 };
                    acc['potion'].count++;
                } else {
                    acc[item.id + Math.random()] = item; // Unique key for unstackables
                }
                return acc;
            }, {});

            Object.values(groupedInv).forEach(item => {
                const slot = document.createElement('div');
                slot.className = 'inv-slot';
                const img = new Image();
                img.src = Assets.cache['item_' + item.id].toDataURL();
                slot.appendChild(img);
                
                if (item.count > 1) {
                    const countEl = document.createElement('div');
                    countEl.className = 'inv-count';
                    countEl.innerText = item.count;
                    slot.appendChild(countEl);
                }

                slot.title = item.name + (item.power ? ` (Power: ${item.power})` : '');
                if (item.slot) { // Is equippable
                    slot.onclick = () => Game.player.equip(item);
                } else { // Is consumable
                    slot.onclick = () => {
                        Game.interact(); // Trigger potion use logic
                        this.toggleInventory(); // Close and refresh
                        setTimeout(() => this.toggleInventory(), 50);
                    };
                }

                grid.appendChild(slot);
            });

            // Update equipment UI
            const equipGrid = document.getElementById('equip-grid');
            equipGrid.innerHTML = '';
            ['weapon', 'armor'].forEach(slotType => {
                const slot = document.createElement('div');
                slot.className = 'inv-slot';
                const equippedItem = Game.player.equipment[slotType];
                if (equippedItem) {
                    const img = new Image();
                    img.src = Assets.cache['item_' + equippedItem.id].toDataURL();
                    slot.appendChild(img);
                    slot.title = equippedItem.name + (equippedItem.power ? ` (Power: ${equippedItem.power})` : '');
                }
                equipGrid.appendChild(slot);
            });
        }
    },

    showQuest(quest) {
        document.getElementById('quest-tracker').classList.remove('hidden');
        document.getElementById('quest-title').innerText = quest.title;
        this.updateQuest();
    },

    updateQuest() {
        const q = Game.player.activeQuest;
        if (!q) return;
        document.getElementById('quest-progress').innerText = `${q.target}: ${q.progress} / ${q.needed}`;
    },

    hideQuest() {
        document.getElementById('quest-tracker').classList.add('hidden');
    },

    showDialogue(npc) {
        const p = Game.player;
        const screen = document.getElementById('dialogue-screen');
        screen.classList.remove('hidden');
        document.getElementById('dialogue-title').innerText = npc.name;
        const textEl = document.getElementById('dialogue-text');

        // Determine which quest this NPC gives
        let quest;
        if (npc.name === 'Wizard') {
            quest = Quests.slimeMenace;
        } else if (npc.name === 'Merchant') {
            quest = Quests.orcMaterials;
        } else if (npc.name === 'Guard Captain') {
            quest = Quests.forestGuardian;
        } else if (npc.name === 'Old Man') {
            quest = Quests.ancientKnowledge;
        } else if (npc.name === 'Librarian') {
            quest = Quests.investigateRuins;
        } else if (npc.name === 'Blacksmith') {
            textEl.innerText = "I can craft powerful items if you bring the materials. What would you like?";
            optionsEl.innerHTML = `
                <button onclick="UI.showCrafting('legendary_sword')">Craft Legendary Sword (5 Iron Ore, 2 Leather Strips)</button>
                <button onclick="UI.closeDialogue()">Nevermind</button>
            `;
            return;
        } else if (npc.name === 'Shady Figure') {
            textEl.innerText = "Strange lights in the ruins, eh? I saw some weird shadows moving around. Be careful out there.";
            optionsEl.innerHTML = `<button onclick="UI.closeDialogue()">Thanks for the warning.</button>`;
            // Check for quest progress
            const q = Game.player.activeQuest;
            if (q && q.type === 'TALK_TO' && q.target === 'Shady Figure' && q.progress < q.needed) {
                q.progress++;
                UI.updateQuest();
            }
            return;
        } else {
            textEl.innerText = "Greetings, traveler."; optionsEl.innerHTML = `<button onclick="UI.closeDialogue()">Goodbye</button>`; return;
        }

        const optionsEl = document.getElementById('dialogue-options');
        optionsEl.innerHTML = '';

        const activeQuest = p.activeQuest;

        // Check for quest turn-in
        let canComplete = false;
        if (activeQuest && activeQuest.id === quest.id) {
            canComplete = activeQuest.progress >= activeQuest.needed;
            if (quest.type === 'GATHER') {
                // Check inventory
                const req = quest.requirements;
                const invCount = {};
                p.inventory.forEach(i => invCount[i.id] = (invCount[i.id] || 0) + (i.count || 1));
                canComplete = true;
                for (let mat in req) {
                    if ((invCount[mat] || 0) < req[mat]) canComplete = false;
                }
                if (canComplete) {
                    // Remove materials
                    for (let mat in req) {
                        let needed = req[mat];
                        p.inventory = p.inventory.filter(i => {
                            if (i.id === mat && needed > 0) {
                                if (i.count) {
                                    i.count -= needed;
                                    needed = 0;
                                    if (i.count <= 0) return false;
                                } else {
                                    needed--;
                                    return false;
                                }
                            }
                            return true;
                        });
                    }
                }
            }
        }
        if (canComplete) {
            textEl.innerText = quest.completionText;
            p.gainXp(quest.reward.xp);
            p.baseStats.gold += quest.reward.gold;
            if (quest.reward.item) {
                p.inventory.push(quest.reward.item);
                this.notify(`Received ${quest.reward.item.name}!`, 'lime');
            }
            this.notify(`+${quest.reward.xp} XP, +${quest.reward.gold} Gold`, 'gold');
            p.activeQuest = null;
            this.hideQuest();

            // BOSS SPAWN!
            if (quest.id === 'slimeMenace') {
                const bossX = p.x + (Math.random() - 0.5) * 200;
                const bossY = p.y - 200; // Spawn above
                Game.entities.push(new Enemy(bossX, bossY, 'orc_king'));
                this.notify("A fearsome Orc King has appeared nearby!", "red");
            }
            optionsEl.innerHTML = `<button onclick="UI.closeDialogue()">Goodbye</button>`;
        } 
        // Check if quest is active but not complete
        else if (activeQuest && activeQuest.id === quest.id) {
            textEl.innerText = "You're still working on my task. Come back when you're done!";
            optionsEl.innerHTML = `<button onclick="UI.closeDialogue()">I'll be back</button>`;
        }
        // Offer quest
        else {
            textEl.innerText = quest.description;
            optionsEl.innerHTML = `
                <button onclick="Game.player.acceptQuest(Quests['${quest.id}']); UI.closeDialogue();">Accept Quest</button>
                <button onclick="UI.closeDialogue()">Decline</button>
            `;
        }
    },

    closeDialogue() {
        document.getElementById('dialogue-screen').classList.add('hidden');
    },

    showShop() {
        const shopItems = [
            { item: { id: 'potion', count: 1 }, cost: 25 },
            { item: { id: 'sword', slot: 'weapon', power: 5 }, cost: 100 },
            { item: { id: 'bow', slot: 'weapon', power: 7 }, cost: 175 },
            { item: { id: 'battle_axe', slot: 'weapon', power: 12 }, cost: 250 },
            { item: { id: 'armor', slot: 'armor', power: 2, name: 'Leather Armor' }, cost: 150 },
            { item: { id: 'steel_armor', slot: 'armor', power: 5, name: 'Steel Armor' }, cost: 300 },
        ];

        const screen = document.getElementById('shop-screen');
        screen.classList.remove('hidden');
        const grid = document.getElementById('shop-grid');
        grid.innerHTML = '';

        // Add Sell functionality
        const sellGrid = document.createElement('div');
        sellGrid.className = 'inventory-grid';
        sellGrid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(64px, 1fr))';
        
        const sellHeader = document.createElement('h2');
        sellHeader.innerText = "Your Items (Click to Sell)";
        sellHeader.style.width = '100%';
        sellHeader.style.textAlign = 'left';

        const shopContainer = document.createElement('div');
        shopContainer.className = 'shop-container'; // Add a class to find and remove it later
        shopContainer.style.display = 'flex';
        shopContainer.style.gap = '40px';

        const buyContainer = document.createElement('div');
        buyContainer.style.width = '500px';
        const sellContainer = document.createElement('div');
        sellContainer.style.width = '300px';

        // Populate Sell Grid
        Game.player.inventory.forEach((item, index) => {
            const slot = document.createElement('div');
            slot.className = 'inv-slot';
            const img = new Image();
            img.src = Assets.cache['item_' + item.id].toDataURL();
            slot.appendChild(img);
            slot.onclick = () => {
                const sellPrice = Math.floor((item.power || 5) * 5); // Simple price logic
                Game.player.baseStats.gold += sellPrice;
                Game.player.inventory.splice(index, 1);
                this.notify(`Sold ${item.id} for ${sellPrice} gold`, 'gold');
                this.closeShop(); setTimeout(() => this.showShop(), 50); // Refresh shop
            };
            sellGrid.appendChild(slot);
        });

        shopItems.forEach(shopItem => {
            const slot = document.createElement('div');
            slot.className = 'inv-slot';
            slot.style.width = '120px';
            slot.style.height = '120px';
            slot.style.flexDirection = 'column';
            
            const img = new Image();
            img.src = Assets.cache['item_' + shopItem.item.id].toDataURL();
            img.style.marginBottom = '10px';

            slot.title = shopItem.item.name + (shopItem.item.power ? ` (Power: ${shopItem.item.power})` : '');
            const info = document.createElement('div');
            info.innerText = `${shopItem.item.id}\nü™ô ${shopItem.cost}`;

            slot.appendChild(img);
            slot.appendChild(info);

            slot.onclick = () => {
                if (Game.player.baseStats.gold >= shopItem.cost) {
                    Game.player.baseStats.gold -= shopItem.cost;
                    Game.player.inventory.push({...shopItem.item});
                    AudioSys.play('coin');
                    this.notify(`Purchased ${shopItem.item.id}!`, 'lime');
                } else {
                    this.notify("Not enough gold!", 'red');
                }
            };

            grid.appendChild(slot);
        });

        buyContainer.appendChild(grid);
        sellContainer.appendChild(sellHeader);
        sellContainer.appendChild(sellGrid);

        shopContainer.appendChild(buyContainer);
        shopContainer.appendChild(sellContainer);
        screen.querySelector('.window').insertBefore(shopContainer, screen.querySelector('button'));
    },

    closeShop() {
        const screen = document.getElementById('shop-screen');
        const oldContainer = screen.querySelector('.shop-container');
        if(oldContainer) oldContainer.remove();
        document.getElementById('shop-screen').classList.add('hidden');
    },

    showCrafting(itemId) {
        const p = Game.player;
        const item = Items.get(itemId);
        const req = { iron_ore: 5, leather_strip: 2 }; // Hardcoded for now
        let hasAll = true;
        const invCount = {};
        p.inventory.forEach(i => invCount[i.id] = (invCount[i.id] || 0) + (i.count || 1));
        for (let mat in req) {
            if ((invCount[mat] || 0) < req[mat]) hasAll = false;
        }
        if (hasAll) {
            // Remove materials
            for (let mat in req) {
                let needed = req[mat];
                p.inventory = p.inventory.filter(i => {
                    if (i.id === mat && needed > 0) {
                        if (i.count) {
                            i.count -= needed;
                            needed = 0;
                            if (i.count <= 0) return false;
                        } else {
                            needed--;
                            return false;
                        }
                    }
                    return true;
                });
            }
            // Add crafted item
            p.inventory.push(item);
            this.notify(`Crafted ${item.name}!`, 'lime');
        } else {
            this.notify("You don't have the required materials.", 'red');
        }
        UI.closeDialogue();
    },

    drawMinimap() {
        if(!this.minimapCanvas) {
            this.minimapCanvas = document.getElementById('minimap');
            this.mCtx = this.minimapCanvas.getContext('2d');
        }
    },

    toggleSkillTree() {
        const el = document.getElementById('skill-tree-screen');
        el.classList.toggle('hidden');
        if (!el.classList.contains('hidden')) {
            this.generateSkillTree();
        }
    },

    generateSkillTree() {
        const container = document.getElementById('skill-tree-container');
        container.innerHTML = '';
        const p = Game.player;

        Object.keys(Skills).forEach(path => {
            const pathDiv = document.createElement('div');
            pathDiv.style.width = '30%';
            const title = document.createElement('h3');
            title.innerText = path.charAt(0).toUpperCase() + path.slice(1);
            pathDiv.appendChild(title);

            Object.keys(Skills[path]).forEach(skillId => {
                const skill = Skills[path][skillId];
                const skillDiv = document.createElement('div');
                skillDiv.style.margin = '10px 0';
                skillDiv.style.padding = '10px';
                skillDiv.style.border = '1px solid #444';
                skillDiv.style.background = '#222';

                const name = document.createElement('div');
                name.innerText = skill.name;
                name.style.fontWeight = 'bold';
                name.style.color = '#fff';

                const desc = document.createElement('div');
                desc.innerText = skill.desc;
                desc.style.fontSize = '14px';
                desc.style.color = '#ccc';

                const level = p.skills[skillId] || 0;
                const levelDiv = document.createElement('div');
                levelDiv.innerText = `Level: ${level}/${skill.max}`;
                levelDiv.style.color = level >= skill.max ? '#0f0' : '#ff0';

                const button = document.createElement('button');
                button.innerText = 'Upgrade';
                button.disabled = p.baseStats.skillPoints <= 0 || level >= skill.max;
                button.onclick = () => {
                    if (p.baseStats.skillPoints > 0 && level < skill.max) {
                        p.skills[skillId] = (p.skills[skillId] || 0) + 1;
                        p.baseStats.skillPoints--;
                        this.applySkillEffect(skillId, p.skills[skillId]);
                        this.toggleSkillTree(); // Refresh
                    }
                };

                skillDiv.appendChild(name);
                skillDiv.appendChild(desc);
                skillDiv.appendChild(levelDiv);
                skillDiv.appendChild(button);
                pathDiv.appendChild(skillDiv);
            });

            container.appendChild(pathDiv);
        });
    },

    applySkillEffect(skillId, level) {
        const p = Game.player;
        if (skillId === 'strength') p.stats.dmg += 5;
        else if (skillId === 'vitality') p.stats.maxHp += 10;
        else if (skillId === 'berserk') p.stats.attackSpeed += 0.1;
        else if (skillId === 'precision') { /* apply to bow damage */ }
        else if (skillId === 'swiftness') p.speed += 20;
        else if (skillId === 'eagle_eye') { /* increase range */ }
        else if (skillId === 'intellect') p.stats.maxMana += 5;
        else if (skillId === 'focus') p.stats.manaRegen += 0.2;
        else if (skillId === 'arcane_power') { /* magic damage */ }
        p.recalculateStats();
    },

    drawMinimap() {
        if(!this.minimapCanvas) {
            this.minimapCanvas = document.getElementById('minimap');
            this.mCtx = this.minimapCanvas.getContext('2d');
        }
        const size = 150;
        this.minimapCanvas.width = size;
        this.minimapCanvas.height = size;
        
        const mx = this.mCtx;
        mx.fillStyle = '#000'; mx.fillRect(0,0,size,size);
        
        const range = 2000; // Range in pixels to show
        const scale = size / range;

        mx.save();
        mx.translate(size/2, size/2);
        
        // Draw Entities relative to player
        Game.entities.forEach(e => {
            const rx = (e.x - Game.player.x) * scale;
            const ry = (e.y - Game.player.y) * scale;
            if(Math.abs(rx) < size/2 && Math.abs(ry) < size/2) {
                mx.fillStyle = 'red';
                mx.fillRect(rx, ry, 2, 2);
            }
            // Special color for boss
            if (e.type === 'orc_king') {
                mx.fillStyle = '#f0f'; // Magenta for boss
                mx.fillRect(rx-2, ry-2, 6, 6);
            }
        });
        Game.entities.forEach(e => {
            if (e instanceof NPC) {
                mx.fillStyle = 'cyan';
                mx.fillRect((e.x - Game.player.x) * scale, (e.y - Game.player.y) * scale, 3, 3);
            }
        });

        // Player
        mx.fillStyle = '#0f0';
        mx.fillRect(-2, -2, 4, 4);
        
        mx.restore();
    }
};

// Start
Game.init();

</script>
</body>
</html>